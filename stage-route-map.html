<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Route Map // Access</title>
  <meta name="description" content="Route-map gate before entering stage-layer-map" />
  <style>
    :root{
      --bg:#06080b;
      --panel: rgba(0,0,0,.18);
      --amber:#ffb14a;
      --amber2:#ff8a2a;
      --line: rgba(255,177,74,.55);
      --line2: rgba(255,177,74,.25);
      --line3: rgba(255,177,74,.12);
      --red:#ff3b3b;
      --green:#39ff7a;
      --mono: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      --sans: system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, "Noto Sans JP", sans-serif;
      --glow: 0 0 16px rgba(255,177,74,.22);
      --glow2: 0 0 26px rgba(255,177,74,.18);
      --shadow: 0 26px 100px rgba(0,0,0,.58);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      color:var(--amber);
      font-family: var(--mono);
      background:
        radial-gradient(1100px 700px at 50% 20%, rgba(255,177,74,.06), transparent 60%),
        radial-gradient(900px 560px at 30% 60%, rgba(255,177,74,.03), transparent 55%),
        var(--bg);
      letter-spacing:.02em;
      overflow-x:hidden;
    }
    /* CRT overlay */
    body::before{
      content:"";
      position:fixed; inset:0;
      pointer-events:none;
      background:
        repeating-linear-gradient(to bottom,
          rgba(255,255,255,.03), rgba(255,255,255,.03) 1px,
          rgba(0,0,0,.00) 2px, rgba(0,0,0,.00) 4px),
        repeating-linear-gradient(90deg,
          rgba(255,177,74,.018), rgba(255,177,74,.018) 1px,
          transparent 2px, transparent 6px),
        radial-gradient(900px 620px at 50% 45%, rgba(255,177,74,.10), transparent 62%);
      mix-blend-mode: screen;
      opacity:.22;
    }
    body::after{
      content:"";
      position:fixed; inset:-20%;
      pointer-events:none;
      background:
        url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='260' height='260'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.85' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='260' height='260' filter='url(%23n)' opacity='.25'/%3E%3C/svg%3E");
      opacity:.09;
      transform: rotate(.6deg);
    }

    .wrap{max-width:1200px; margin:0 auto; padding:18px 18px 30px;}
    .frame{
      position:relative;
      border:2px solid var(--line);
      background: linear-gradient(180deg, rgba(255,177,74,.028), transparent 40%), var(--panel);
      box-shadow: var(--shadow);
      padding: 12px;
      overflow:hidden;
    }
    .frame::before{content:""; position:absolute; inset:10px; border:1px solid var(--line2); pointer-events:none;}

    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      font-size:12px;
      padding:2px 4px 10px;
      opacity:.95;
    }
    .topbar a{color:inherit; text-decoration:none}
    .chip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      border:1px solid var(--line);
      padding: 2px 10px;
      background: rgba(255,177,74,.06);
      box-shadow: var(--glow);
      font-weight:700;
      letter-spacing:.06em;
      user-select:none;
      white-space:nowrap;
    }
    .chip--link{cursor:pointer}
    .chip--link:hover{background: rgba(255,177,74,.10)}
    .chip--danger{border-color: rgba(255,59,59,.7); box-shadow: 0 0 16px rgba(255,59,59,.16)}

    .headline{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:12px;
      padding: 6px 4px 12px;
      border-bottom:1px solid var(--line2);
      margin-bottom: 12px;
    }
    .h1{
      margin:0;
      font-family: var(--sans);
      font-size: 46px;
      line-height: 1;
      letter-spacing: -0.03em;
      text-shadow: var(--glow2);
    }
    .sub{margin:0 0 6px; font-size:12px; opacity:.86; text-align:right; max-width:560px;}

    .layout{display:grid; grid-template-columns: 1fr; gap:12px;}
    .mapWrap{
      position:relative;
      border:1px solid var(--line2);
      background: rgba(0,0,0,.18);
      box-shadow: var(--glow);
      overflow:hidden;
      padding:10px;
      min-height: 440px;
    }
    .mapWrap::before{
      content:"";
      position:absolute; inset:0;
      background:
        linear-gradient(transparent, rgba(255,177,74,.03)),
        repeating-linear-gradient(90deg, rgba(255,177,74,.04) 0, rgba(255,177,74,.04) 1px, transparent 1px, transparent 120px),
        repeating-linear-gradient(0deg, rgba(255,177,74,.03) 0, rgba(255,177,74,.03) 1px, transparent 1px, transparent 90px);
      opacity:.16;
      pointer-events:none;
    }

    svg{width:100%; height: 420px; display:block; position:relative; z-index:1}

    .hud{
      display:flex;
      flex-wrap:wrap;
      gap:10px 12px;
      align-items:center;
      justify-content:space-between;
      padding: 8px 4px 2px;
      border-top:1px solid var(--line2);
      margin-top: 8px;
      position:relative;
      z-index:2;
    }
    .hudLeft{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .label{opacity:.86; font-size:12px}
    .input{
      width:min(720px, 100%);
      border:1px solid var(--line2);
      background: rgba(255,177,74,.06);
      color: var(--amber);
      font-family: var(--mono);
      font-size: 14px;
      padding: 10px 10px;
      outline:none;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.25);
    }
    .btnrow{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .btn{
      cursor:pointer;
      border:1px solid var(--line);
      background: rgba(255,177,74,.07);
      color: var(--amber);
      font-family: var(--sans);
      font-weight: 900;
      letter-spacing:.08em;
      padding: 10px 12px;
      box-shadow: var(--glow);
      user-select:none;
    }
    .btn:disabled{opacity:.45; cursor:not-allowed}
    .status{font-size:12px; opacity:.9}
    .status .ok{color:var(--green)}
    .status .bad{color:var(--red)}
    .hint{font-size:12px; opacity:.72}

    /* SVG styling */
    .edge{stroke: rgba(255,177,74,.34); stroke-width:2;}
    .edge.active{stroke: rgba(57,255,122,.70); stroke-width:2.6; filter: drop-shadow(0 0 8px rgba(57,255,122,.16));}
    .node rect{
      fill: rgba(255,177,74,.10);
      stroke: rgba(255,177,74,.62);
      stroke-width:1.2;
      rx:3; ry:3;
      filter: drop-shadow(0 0 10px rgba(255,177,74,.12));
    }
    .node text{fill: var(--amber); font-size:12px; font-weight:700}
    .node{cursor:pointer}
    .node:hover rect{fill: rgba(255,177,74,.16)}
    .node.active rect{stroke: rgba(57,255,122,.82); fill: rgba(57,255,122,.12)}
    .node.active text{fill: var(--green)}
    .node.hit rect{stroke: rgba(255,59,59,.92); fill: rgba(255,59,59,.18)}
    .node.hit text{fill: var(--red)}
    .cross{stroke: rgba(255,177,74,.22); stroke-width:2;}
    .border{stroke: rgba(255,177,74,.30); fill: none; stroke-width:2;}

    /* === Access Sequence Overlay (percent ring -> decrypt panel) === */
    .seq{
      position:absolute;
      inset:0;
      z-index: 3;
      pointer-events:none;
      opacity:0;
      transition: opacity .25s ease;
    }
    .seq.on{ opacity:1; }

    .ringPane{
      position:absolute;
      left:50%;
      top: 10px;
      transform: translateX(-50%) translateY(-10px);
      width:min(820px, 96%);
      height: 300px;
      overflow:hidden;
      opacity:0;
      filter: drop-shadow(0 0 18px rgba(255,177,74,.14));
      transition: opacity .35s ease, transform .35s ease;
      pointer-events:none;
    }
    .ringPane.on{ opacity:1; transform: translateX(-50%) translateY(0); }

    .ring{
      position:absolute;
      left:50%;
      top: -150px;
      transform: translateX(-50%);
      width: 560px;
      height: 560px;
      border-radius: 50%;
      background:
        radial-gradient(circle at 50% 50%, rgba(0,0,0,.86) 0 38%, transparent 38% 100%),
        radial-gradient(circle at 50% 50%, rgba(255,177,74,.10) 0 42%, rgba(255,177,74,.04) 42% 100%),
        repeating-conic-gradient(from -18deg,
          rgba(255,177,74,.62) 0 1.8deg,
          rgba(255,177,74,.06) 1.8deg 6deg);
      border: 2px solid rgba(255,177,74,.28);
      box-shadow: inset 0 0 0 1px rgba(255,177,74,.10);
    }
    .ring::before{
      content:"";
      position:absolute; inset: 34px;
      border-radius: 50%;
      border: 1px solid rgba(255,177,74,.22);
      box-shadow: inset 0 0 0 1px rgba(255,177,74,.08);
    }
    .ring::after{
      content:"";
      position:absolute;
      inset: 0;
      border-radius: 50%;
      background:
        radial-gradient(circle at 50% 50%, rgba(255,177,74,.10), transparent 62%),
        repeating-radial-gradient(circle at 50% 50%, rgba(255,177,74,.08) 0 2px, transparent 2px 18px);
      opacity:.35;
      mix-blend-mode: screen;
      pointer-events:none;
    }
    .ringMarks{
      position:absolute;
      left:50%; top:-150px;
      transform: translateX(-50%);
      width:560px; height:560px;
      pointer-events:none;
    }
    .ringHud{
      position:absolute;
      left:50%;
      top: 96px;
      transform: translateX(-50%);
      display:flex;
      align-items:flex-end;
      gap: 10px;
      pointer-events:none;
    }
    .ringHud .meta{
      font-family: var(--sans);
      font-weight: 900;
      letter-spacing: .06em;
      font-size: 12px;
      opacity:.86;
      text-shadow: var(--glow2);
      white-space:nowrap;
    }
    .pct{
      display:flex;
      align-items:flex-end;
      gap:6px;
      font-family: var(--sans);
      font-weight: 1000;
      text-shadow: var(--glow2);
    }
    .pct .digits{display:flex; gap:4px;}
    .digit{
      width: 46px;
      height: 70px;
      border: 2px solid rgba(255,177,74,.55);
      background: rgba(0,0,0,.40);
      box-shadow: inset 0 0 0 1px rgba(255,177,74,.10);
      display:grid;
      place-items:center;
      font-size: 56px;
      line-height: 1;
      letter-spacing: .02em;
    }
    .pct .sym{font-size: 30px; opacity:.9; margin-bottom: 10px;}

    .decryptPane{
      position:absolute;
      left:50%;
      bottom: 14px;
      transform: translateX(-50%) rotateX(90deg) translateZ(-120px);
      transform-origin: 50% 100%;
      width:min(1040px, 98%);
      border: 2px solid rgba(255,177,74,.34);
      background: linear-gradient(180deg, rgba(255,177,74,.04), rgba(0,0,0,.34));
      box-shadow: 0 30px 120px rgba(0,0,0,.62);
      opacity:0;
      transition: transform .55s cubic-bezier(.2,.9,.2,1), opacity .55s ease;
      pointer-events:none;
    }
    .decryptPane.on{opacity:1; transform: translateX(-50%) rotateX(0deg) translateZ(0); pointer-events:auto;}
    .decryptPane::before{content:""; position:absolute; inset:10px; border:1px solid rgba(255,177,74,.22); pointer-events:none;}

    .decryptTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding: 12px 14px 10px;
      border-bottom: 1px solid rgba(255,177,74,.20);
    }
    .decryptTitle{
      font-family: var(--sans);
      font-weight: 1000;
      letter-spacing: -0.02em;
      font-size: 40px;
      text-shadow: var(--glow2);
      margin:0;
    }
    .decryptMeta{font-size:12px; opacity:.86}
    .restartBtn{
      pointer-events:auto;
      cursor:pointer;
      border: 1px solid rgba(255,177,74,.50);
      background: rgba(255,177,74,.10);
      color: var(--amber);
      font-family: var(--sans);
      font-weight: 1000;
      letter-spacing: .08em;
      padding: 12px 14px;
      box-shadow: var(--glow);
      user-select:none;
    }
    .restartBtn:hover{ background: rgba(255,177,74,.14) }

    .decryptBody{ padding: 10px 14px 14px; }
    .puzzleNote{
      display:flex;
      justify-content:space-between;
      gap: 12px;
      align-items:center;
      font-size:12px;
      opacity:.86;
      padding: 0 2px 10px;
    }
    .puzzleNote b{color: var(--green)}
    .stripWrap{
      border:1px solid rgba(255,177,74,.22);
      background: rgba(0,0,0,.22);
      overflow-x:auto;
      overflow-y:hidden;
      padding: 12px 10px;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.35);
    }
    .strip{
      display:flex;
      gap: 8px;
      align-items:flex-end;
      min-width: 980px;
      padding-bottom: 10px;
    }
    .cyl{
      width: 26px;
      height: 160px;
      border: 1px solid rgba(255,177,74,.28);
      background: rgba(0,0,0,.18);
      position:relative;
      box-shadow: inset 0 0 0 1px rgba(255,177,74,.06);
      user-select:none;
      touch-action:none;
    }
    .cyl::before{content:""; position:absolute; inset:6px 6px 28px; border:1px dashed rgba(255,177,74,.14);} 
    .cyl.focus{outline: 2px solid rgba(57,255,122,.55); outline-offset: 2px; box-shadow: 0 0 18px rgba(57,255,122,.10), inset 0 0 0 1px rgba(255,177,74,.06)}
    .handle{
      position:absolute;
      left: 4px;
      right: 4px;
      top: 22px;
      height: 70px;
      border: 1px solid rgba(255,177,74,.55);
      background: linear-gradient(180deg, rgba(255,177,74,.16), rgba(255,177,74,.06));
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.30);
      transform: translateY(var(--off, 0px));
      will-change: transform;
      cursor: ns-resize;
    }
    .cyl.locked .handle{border-color: rgba(57,255,122,.72); background: linear-gradient(180deg, rgba(57,255,122,.22), rgba(57,255,122,.08)); cursor: default;}
    .fill{position:absolute; left:6px; right:6px; bottom:28px; height:0; background: rgba(255,177,74,.16); transition: height .35s ease; pointer-events:none;}
    .cyl.locked .fill{ height: 122px; background: rgba(255,177,74,.22); }
    .idx{position:absolute; left:0; right:0; bottom:0; height:24px; display:grid; place-items:center; font-size:10px; opacity:.82; border-top: 1px solid rgba(255,177,74,.18); background: rgba(0,0,0,.16);}

    .progressRow{display:flex; align-items:center; justify-content:space-between; gap: 12px; margin-top: 10px; font-size: 12px; opacity:.88;}
    .bar{flex:1; height: 8px; border: 1px solid rgba(255,177,74,.26); background: rgba(0,0,0,.18); overflow:hidden;}
    .bar > i{display:block; height:100%; width: 0%; background: rgba(57,255,122,.28); transition: width .25s ease;}

    @media (max-width:700px){
      svg{height: 360px}
      .h1{font-size: 36px}
      .sub{text-align:left}
      .digit{width: 42px; height: 64px; font-size: 52px}
      .ringHud{top: 90px}
    }
  </style>
</head>
<body>
  <main class="wrap">
    <section class="frame" aria-label="route-map gate">
      <div class="topbar">
        <div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center">
          <a class="chip chip--link" href="index.html">← HOME</a>
          <span class="chip">MODE: <b>ROUTE</b></span>
          <span class="chip chip--danger">LOCKED</span>
        </div>
        <div style="display:flex; gap:8px; align-items:center">
          <span class="chip" id="nextChip">NEXT: <b>stage-layer-map.html</b></span>
          <span class="chip" id="clock">--:--:--</span>
        </div>
      </div>

      <div class="headline">
        <h1 class="h1">ROUTE MAP</h1>
        <p class="sub">枝分かれに沿ってブロック文字を入力し、末端ターゲットに到達せよ。到達するとブロックが赤化し、復号パネルへ遷移する。</p>
      </div>

      <div class="layout">
        <div class="mapWrap">
          <svg id="svg" viewBox="0 0 1000 620" role="img" aria-label="route map">
            <!-- drawn by JS -->
          </svg>

          <!-- Access sequence overlay (hidden until TARGET reached) -->
          <div class="seq" id="seq" aria-hidden="true">
            <div class="ringPane" id="ringPane">
              <div class="ring"></div>
              <svg class="ringMarks" viewBox="0 0 560 560" aria-hidden="true">
                <g fill="none" stroke="rgba(255,177,74,.28)" stroke-width="2">
                  <path d="M280 44 L280 96" />
                  <path d="M280 464 L280 516" opacity=".35"/>
                  <path d="M44 280 L96 280" opacity=".35"/>
                  <path d="M464 280 L516 280" opacity=".35"/>
                </g>
                <g stroke="rgba(255,177,74,.22)" stroke-width="1" fill="none">
                  <circle cx="280" cy="280" r="212" />
                  <circle cx="280" cy="280" r="178" opacity=".55"/>
                  <circle cx="280" cy="280" r="144" opacity=".35"/>
                </g>
              </svg>
              <div class="ringHud">
                <div class="meta">STAGE <b>04</b>&nbsp; /&nbsp; SEC.10&nbsp; /&nbsp; SIDE-B</div>
                <div class="pct" aria-label="percent">
                  <div class="digits">
                    <div class="digit" id="d1">0</div>
                    <div class="digit" id="d2">0</div>
                    <div class="digit" id="d3">0</div>
                  </div>
                  <div class="sym">%</div>
                </div>
              </div>
            </div>

            <section class="decryptPane" id="decryptPane" aria-label="Decryption Key panel">
              <div class="decryptTop">
                <div>
                  <h2 class="decryptTitle">Decryption Key</h2>
                  <div class="decryptMeta">Black Chamber / NERV Sealing Pillar No.01&nbsp;&nbsp;|&nbsp;&nbsp;<span id="decryptState">Interlink: Nominal</span>&nbsp;&nbsp;|&nbsp;&nbsp;AI Systems: Locked</div>
                </div>
                <button class="restartBtn" id="restartBtn" type="button">RESTART DECRYPTION</button>
              </div>

              <div class="decryptBody">
                <div class="puzzleNote">
                  <div>各シリンダ（縦バー）を <b>正しい位置</b> に合わせろ。合致すると固定され、次のバーへ移行する。</div>
                  <div id="puzzleMsg">TARGET CYLINDERS: <b>--/--</b></div>
                </div>

                <div class="stripWrap">
                  <div class="strip" id="strip" aria-label="cylinder puzzle"></div>
                </div>

                <div class="progressRow">
                  <div id="puzzleStatus">DECRYPTING… Align cylinders</div>
                  <div class="bar" aria-hidden="true"><i id="pbar"></i></div>
                </div>
              </div>
            </section>
          </div>

          <div class="hud">
            <div class="hudLeft">
              <div class="label">ROUTE:</div>
              <input class="input" id="routeIn" placeholder="例: R0 A1 B1 C2 STAGE  (space or > で区切り)" autocomplete="off" spellcheck="false" />
            </div>
            <div class="btnrow">
              <button class="btn" id="resetBtn" type="button">RESET</button>
              <button class="btn" id="goBtn" type="button" disabled>ACCESS</button>
            </div>
          </div>
          <div class="hud" style="border-top:none; padding-top:0; margin-top:0;">
            <div class="status" id="status"><span class="hint">クリックでノードを追加してもOK。最初は <b>R0</b> から。</span></div>
            <div class="hint" id="hint"></div>
          </div>
        </div>
      </div>
    </section>
  </main>

  <script>
    (() => {
      const KEY = "MAGI_STAGE_UNLOCK";
      const qs = new URLSearchParams(location.search);
      const next = (qs.get("next") || "stage-layer-map.html").replace(/\s/g, "");

      // Show next target in UI
      const nextChip = document.getElementById("nextChip");
      if(nextChip){
        const b = nextChip.querySelector("b");
        if(b) b.textContent = next;
      }

      // clock
      const clock = document.getElementById("clock");
      const tick = () => {
        const d = new Date();
        const z = (n) => String(n).padStart(2,"0");
        if(clock) clock.textContent = `${z(d.getHours())}:${z(d.getMinutes())}:${z(d.getSeconds())}`;
      };
      tick();
      setInterval(tick, 1000);

      // tiny beep
      let ac;
      function beep(freq=880, ms=60, type="square", gain=0.03){
        try {
          ac = ac || new (window.AudioContext || window.webkitAudioContext)();
          const o = ac.createOscillator();
          const g = ac.createGain();
          o.type = type;
          o.frequency.value = freq;
          g.gain.value = gain;
          o.connect(g); g.connect(ac.destination);
          o.start();
          setTimeout(() => { try{o.stop();}catch(e){} }, ms);
        } catch(e){}
      }

      const svg = document.getElementById("svg");
      const routeIn = document.getElementById("routeIn");
      const resetBtn = document.getElementById("resetBtn");
      const goBtn = document.getElementById("goBtn");
      const status = document.getElementById("status");
      const hint = document.getElementById("hint");

      const seq = document.getElementById("seq");
      const ringPane = document.getElementById("ringPane");
      const decryptPane = document.getElementById("decryptPane");
      const restartBtn = document.getElementById("restartBtn");
      const d1 = document.getElementById("d1");
      const d2 = document.getElementById("d2");
      const d3 = document.getElementById("d3");
      const strip = document.getElementById("strip");
      const puzzleMsg = document.getElementById("puzzleMsg");
      const puzzleStatus = document.getElementById("puzzleStatus");
      const pbar = document.getElementById("pbar");
      const decryptState = document.getElementById("decryptState");

      const ROOT = "R0";
      const TARGET = "STAGE";
      const WIDTH = 1000; // svg viewBox width

      // Node map. Coordinates are mirrored so the branching flows left -> right.
      const NODES_RAW = [
        // root
        {label:"R0", x:940, y:310},

        // layer 1
        {label:"A1", x:770, y:150},
        {label:"A2", x:770, y:310},
        {label:"A3", x:770, y:470},

        // layer 2
        {label:"B1", x:600, y:90},
        {label:"B2", x:600, y:210},
        {label:"B3", x:600, y:280},
        {label:"B4", x:600, y:360},
        {label:"B5", x:600, y:430},
        {label:"B6", x:600, y:530},

        // layer 3
        {label:"C1", x:430, y:70},
        {label:"C2", x:430, y:130},
        {label:"C3", x:430, y:190},
        {label:"C4", x:430, y:250},
        {label:"C5", x:430, y:300},
        {label:"C6", x:430, y:350},
        {label:"C7", x:430, y:420},
        {label:"C8", x:430, y:470},
        {label:"C9", x:430, y:520},
        {label:"C10",x:430, y:570},

        // layer 4
        {label:"D1", x:260, y:60},
        {label:"D2", x:260, y:95},
        {label:"D3", x:260, y:130},
        {label:"D4", x:260, y:180},
        {label:"D5", x:260, y:220},
        {label:"D6", x:260, y:260},
        {label:"D7", x:260, y:300},
        {label:"D8", x:260, y:330},
        {label:"D9", x:260, y:360},
        {label:"D10",x:260, y:420},
        {label:"D11",x:260, y:450},
        {label:"D12",x:260, y:480},
        {label:"D13",x:260, y:520},
        {label:"D14",x:260, y:550},
        {label:"D15",x:260, y:590},

        // leaves
        {label:"L01", x:110, y:105},
        {label:"STAGE", x:80, y:140},
        {label:"L02", x:110, y:175},
        {label:"L03", x:110, y:205},
        {label:"L04", x:110, y:235},
        {label:"L05", x:110, y:300},
        {label:"L06", x:110, y:420},
        {label:"L07", x:110, y:525},
        {label:"L08", x:110, y:585},
      ];

      const NODES = NODES_RAW.map(n => ({...n, x: (WIDTH - n.x)}));

      const EDGES = [
        ["R0","A1"],["R0","A2"],["R0","A3"],
        ["A1","B1"],["A1","B2"],
        ["A2","B3"],["A2","B4"],
        ["A3","B5"],["A3","B6"],

        ["B1","C1"],["B1","C2"],
        ["B2","C3"],["B2","C4"],
        ["B3","C5"],["B3","C6"],
        ["B4","C6"],["B4","C7"],
        ["B5","C7"],["B5","C8"],["B5","C9"],
        ["B6","C9"],["B6","C10"],

        ["C1","D1"],["C1","D2"],
        ["C2","D3"],
        ["C3","D4"],["C3","D5"],
        ["C4","D6"],
        ["C5","D7"],["C5","D8"],
        ["C6","D8"],["C6","D9"],
        ["C7","D10"],["C7","D11"],
        ["C8","D12"],
        ["C9","D13"],["C9","D14"],
        ["C10","D15"],

        ["D3","L01"],["D3","STAGE"],["D3","L02"],
        ["D4","L03"],["D5","L04"],
        ["D7","L05"],["D10","L06"],["D13","L07"],["D15","L08"],
      ];

      const nodeByLabel = Object.fromEntries(NODES.map(n => [n.label, n]));
      const edgeSet = new Set(EDGES.map(([a,b]) => `${a}→${b}`));
      const out = {};
      for(const [a,b] of EDGES){ (out[a] ||= []).push(b); }

      function el(name, attrs={}){
        const e = document.createElementNS("http://www.w3.org/2000/svg", name);
        for(const [k,v] of Object.entries(attrs)) e.setAttribute(k, v);
        return e;
      }

      function clearSvg(){ while(svg.firstChild) svg.removeChild(svg.firstChild); }

      function drawBase(){
        // border
        svg.appendChild(el("rect", {x:24, y:24, width:952, height:572, class:"border"}));

        // crosses like the reference
        const crosses = [
          [85,70],[160,520],[520,85],[520,530],[905,120],[905,490],[120,320],[880,320]
        ];
        for(const [cx,cy] of crosses){
          svg.appendChild(el("line", {x1:cx-12,y1:cy,x2:cx+12,y2:cy, class:"cross"}));
          svg.appendChild(el("line", {x1:cx,y1:cy-12,x2:cx,y2:cy+12, class:"cross"}));
        }
      }

      const edgeEls = new Map();
      const nodeEls = new Map();

      function drawGraph(){
        clearSvg();
        drawBase();

        // edges first
        for(const [a,b] of EDGES){
          const na = nodeByLabel[a];
          const nb = nodeByLabel[b];
          if(!na || !nb) continue;
          const line = el("line", {x1:na.x, y1:na.y, x2:nb.x, y2:nb.y, class:"edge"});
          svg.appendChild(line);
          edgeEls.set(`${a}→${b}`, line);
        }

        // nodes
        for(const n of NODES){
          const w = Math.max(44, (n.label.length * 8) + 18);
          const h = 22;
          const g = el("g", {class:"node", "data-label": n.label, transform:`translate(${n.x} ${n.y})`});
          const r = el("rect", {x: -w/2, y: -h/2, width: w, height: h});
          const t = el("text", {x:0, y:4, "text-anchor":"middle"});
          t.textContent = n.label;
          g.appendChild(r);
          g.appendChild(t);
          svg.appendChild(g);
          nodeEls.set(n.label, g);
        }
      }

      function parseRoute(s){
        return (s || "")
          .split(/[\s>\/]+/)
          .map(x => x.trim())
          .filter(Boolean)
          .map(x => x.toUpperCase());
      }

      function setStatus(html){ if(status) status.innerHTML = html; }
      function setHint(txt){ if(hint) hint.textContent = txt || ""; }

      function validate(route){
        if(route.length === 0) return {ok:false, partial:true, msg:""};
        if(route[0] !== ROOT) return {ok:false, partial:false, msg:`先頭は <b>${ROOT}</b> から。`};
        for(let i=0;i<route.length;i++){
          if(!nodeByLabel[route[i]]) return {ok:false, partial:false, msg:`未知ノード: <b>${escapeHtml(route[i])}</b>`};
          if(i===0) continue;
          const a = route[i-1], b = route[i];
          if(!edgeSet.has(`${a}→${b}`)) return {ok:false, partial:false, msg:`接続なし: <b>${escapeHtml(a)}</b> → <b>${escapeHtml(b)}</b>`};
        }
        const last = route[route.length-1];
        const isLeaf = !out[last] || out[last].length === 0;
        const isTarget = last === TARGET;
        return {ok:true, last, isLeaf, isTarget};
      }

      function escapeHtml(s){
        return String(s).replace(/[&<>"]/g, (c) => ({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;"}[c]));
      }

      function clearHighlights(){
        for(const g of nodeEls.values()) g.classList.remove("active","hit");
        for(const l of edgeEls.values()) l.classList.remove("active");
      }

      let autoTimer = null;
      let seqStarted = false;
      let puzzleReady = false;

      function applyRoute(){
        const route = parseRoute(routeIn.value);
        clearHighlights();
        goBtn.disabled = true;
        if(autoTimer){ clearTimeout(autoTimer); autoTimer = null; }

        const res = validate(route);
        if(!route.length){
          setStatus(`<span class="hint">クリックでノードを追加してもOK。最初は <b>${ROOT}</b> から。</span>`);
          setHint("例: R0 > A1 > B1 > C2 > D3 > STAGE");
          return;
        }

        // highlight nodes + edges
        for(let i=0;i<route.length;i++){
          const lab = route[i];
          nodeEls.get(lab)?.classList.add("active");
          if(i>0){
            edgeEls.get(`${route[i-1]}→${route[i]}`)?.classList.add("active");
          }
        }

        if(!res.ok){
          setStatus(`<span class="bad">ROUTE ERROR</span> / ${res.msg}`);
          setHint("分岐に沿った順序で入力しているか確認");
          return;
        }

        if(res.isTarget){
          nodeEls.get(TARGET)?.classList.add("hit");
          setStatus(`<span class="ok">TARGET LOCK</span> / <b>${TARGET}</b> reached`);
          setHint("Decryption sequence start…");
          beginSequence();
          return;
        }

        const nexts = out[res.last] || [];
        const nextText = nexts.length ? `next: ${nexts.map(x=>`<b>${escapeHtml(x)}</b>`).join(" ")}` : "dead end";
        setStatus(`<span class="ok">ROUTE OK</span> / current: <b>${escapeHtml(res.last)}</b> / ${nextText}`);
        setHint("末端まで入力するとターゲットが赤化");
      }

      function armAndGo(){
        if(!puzzleReady) return;
        try{ sessionStorage.setItem(KEY, "1"); }catch(e){}
        beep(1040, 70, "square", 0.04);
        setStatus(`<span class="ok">ACCESS GRANTED</span> / redirecting...`);
        setHint("");
        setTimeout(() => { location.href = next; }, 650);
      }

      function appendToken(tok){
        if(seqStarted) return;
        const cur = parseRoute(routeIn.value);
        if(cur.length === 0){
          routeIn.value = tok;
          applyRoute();
          return;
        }
        const cand = [...cur, tok];
        const res = validate(cand);
        if(res.ok){
          routeIn.value = cand.join(" ");
          beep(900, 35, "square", 0.03);
          applyRoute();
        } else {
          beep(240, 110, "sawtooth", 0.02);
          setStatus(`<span class="bad">DENIED</span> / ${res.msg || "invalid"}`);
        }
      }

      // === Sequence + Puzzle ===
      const PUZZLE_N = 28;
      const LIM = 22;
      const SNAP = 3;
      let targets = [];
      let offsets = [];
      let locked = [];
      let focus = 0;

      function setDigits(n){
        const s = String(Math.max(0, Math.min(999, n))).padStart(3,"0");
        if(d1) d1.textContent = s[0];
        if(d2) d2.textContent = s[1];
        if(d3) d3.textContent = s[2];
      }

      function beginSequence(){
        if(seqStarted) return;
        seqStarted = true;

        // lock route input UI
        routeIn.disabled = true;
        resetBtn.disabled = true;
        goBtn.disabled = true;

        // show overlay
        seq?.classList.add("on");
        seq?.setAttribute("aria-hidden","false");
        ringPane?.classList.add("on");

        // percent animation to 037
        const targetPct = 37;
        let cur = 0;
        setDigits(0);
        const t = setInterval(() => {
          cur += 1;
          setDigits(cur);
          if(cur % 3 === 0) beep(840 + (cur%12)*20, 18, "square", 0.02);
          if(cur >= targetPct){
            clearInterval(t);
            beep(1040, 70, "square", 0.03);
          }
        }, 26);

        setTimeout(() => {
          decryptPane?.classList.add("on");
          initPuzzle();
        }, 1150);
      }

      function mkTarget(i){
        const base = ((i * 7) % 11) - 5; // -5..5
        return Math.max(-LIM, Math.min(LIM, base * 4));
      }
      function rnd(min,max){
        return Math.floor(Math.random()*(max-min+1))+min;
      }

      function updatePuzzleUi(){
        const done = locked.filter(Boolean).length;
        const pct = Math.round((done / PUZZLE_N) * 100);
        if(puzzleMsg) puzzleMsg.innerHTML = `TARGET CYLINDERS: <b>${done}/${PUZZLE_N}</b>`;
        if(pbar) pbar.style.width = `${pct}%`;
        if(puzzleStatus){
          if(done >= PUZZLE_N){
            puzzleStatus.textContent = "DECRYPTION COMPLETE";
          } else {
            puzzleStatus.textContent = `DECRYPTING… Align cylinder ${focus+1}`;
          }
        }
      }

      function setFocus(i){
        focus = i;
        for(const el of strip?.children || []) el.classList.remove("focus");
        const cur = strip?.querySelector(`.cyl[data-i="${i}"]`);
        cur?.classList.add("focus");
        cur?.scrollIntoView({behavior:"smooth", inline:"center", block:"nearest"});
        updatePuzzleUi();
      }

      function nextFocus(){
        for(let i=focus+1;i<PUZZLE_N;i++) if(!locked[i]) return setFocus(i);
        for(let i=0;i<PUZZLE_N;i++) if(!locked[i]) return setFocus(i);
      }

      function lockCyl(i){
        locked[i] = true;
        offsets[i] = targets[i];
        const el = strip?.querySelector(`.cyl[data-i="${i}"]`);
        if(el){
          el.classList.add("locked");
          const h = el.querySelector(".handle");
          if(h) h.style.setProperty("--off", `${offsets[i]}px`);
        }
        beep(980, 55, "square", 0.03);
        updatePuzzleUi();

        if(locked.every(Boolean)){
          onPuzzleComplete();
        } else {
          nextFocus();
        }
      }

      function onPuzzleComplete(){
        puzzleReady = true;
        if(decryptState) decryptState.textContent = "Interlink: Nominal";
        beep(1140, 90, "square", 0.04);
        goBtn.disabled = false;
        setStatus(`<span class="ok">DECRYPTION OK</span> / all cylinders aligned`);
        setHint("Access will open…");
        setTimeout(() => armAndGo(), 850);
      }

      function renderPuzzle(){
        if(!strip) return;
        strip.innerHTML = "";
        for(let i=0;i<PUZZLE_N;i++){
          const cyl = document.createElement("div");
          cyl.className = "cyl" + (i===focus ? " focus":"");
          cyl.dataset.i = String(i);
          cyl.innerHTML = `
            <div class="fill"></div>
            <div class="handle" style="--off:${offsets[i]}px"></div>
            <div class="idx">${String(i+1).padStart(2,"0")}</div>
          `;
          if(locked[i]) cyl.classList.add("locked");
          strip.appendChild(cyl);
        }
        updatePuzzleUi();
      }

      function initPuzzle(){
        targets = Array.from({length:PUZZLE_N}, (_,i) => mkTarget(i));
        offsets = Array.from({length:PUZZLE_N}, (_,i) => {
          let v = targets[i] + rnd(-LIM, LIM);
          v = Math.max(-LIM, Math.min(LIM, v));
          if(Math.abs(v - targets[i]) < 2) v = Math.max(-LIM, Math.min(LIM, v + 6));
          return v;
        });
        locked = Array.from({length:PUZZLE_N}, () => false);
        focus = 0;
        renderPuzzle();
        setFocus(0);
        if(decryptState) decryptState.textContent = "Interlink: Nominal";
      }

      // puzzle drag (vertical)
      let dragI = -1;
      let startY = 0;
      let startOff = 0;

      strip?.addEventListener("pointerdown", (e) => {
        const cyl = e.target.closest?.(".cyl");
        if(!cyl) return;
        const i = Number(cyl.dataset.i);
        if(Number.isNaN(i) || locked[i]) return;
        // Sequential: only the current focused cylinder can be adjusted.
        if(i !== focus){
          beep(240, 70, "sawtooth", 0.018);
          return;
        }
        dragI = i;
        startY = e.clientY;
        startOff = offsets[i];
        cyl.setPointerCapture?.(e.pointerId);
        beep(760, 24, "square", 0.02);
      });

      strip?.addEventListener("pointermove", (e) => {
        if(dragI < 0) return;
        const dy = e.clientY - startY;
        const v = Math.max(-LIM, Math.min(LIM, startOff + dy));
        offsets[dragI] = v;
        const el = strip?.querySelector(`.cyl[data-i="${dragI}"] .handle`);
        if(el) el.style.setProperty("--off", `${v}px`);
      });

      function endDrag(){
        if(dragI < 0) return;
        const i = dragI;
        dragI = -1;
        const dist = Math.abs(offsets[i] - targets[i]);
        if(dist <= SNAP){
          lockCyl(i);
        } else {
          beep(280, 60, "sawtooth", 0.018);
          updatePuzzleUi();
        }
      }

      strip?.addEventListener("pointerup", endDrag);
      strip?.addEventListener("pointercancel", endDrag);

      restartBtn?.addEventListener("click", () => {
        if(!seqStarted) return;
        puzzleReady = false;
        goBtn.disabled = true;
        beep(520, 55, "square", 0.03);
        initPuzzle();
        setStatus(`<span class="ok">RESTART</span> / decryption reset`);
        setHint("Align cylinders again");
      });

      // init
      drawGraph();
      applyRoute();

      routeIn.addEventListener("input", () => { if(!seqStarted) applyRoute(); });
      routeIn.addEventListener("keydown", (e) => {
        if(e.key === "Enter"){
          e.preventDefault();
          if(puzzleReady) armAndGo();
        }
      });
      resetBtn.addEventListener("click", () => {
        if(seqStarted) return;
        routeIn.value = "";
        routeIn.disabled = false;
        resetBtn.disabled = false;
        goBtn.disabled = true;
        beep(520, 55, "square", 0.03);
        applyRoute();
      });
      goBtn.addEventListener("click", armAndGo);

      svg.addEventListener("click", (e) => {
        if(seqStarted) return;
        const g = e.target.closest(".node");
        if(!g) return;
        const label = g.getAttribute("data-label");
        if(!label) return;
        appendToken(label);
      });

      // Auto-focus
      setTimeout(() => routeIn.focus(), 100);
    })();
  </script>
</body>
</html>
